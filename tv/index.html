<!DOCTYPE html>
<html>
<head>
<title>ateaish TV</title>
<link rel="icon" type="image/png" href="assets/favicon_tv_150ppi.png">
<script type="text/javascript" src="https://cdn.embed.ly/player-0.1.0.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script type="text/javascript" src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
<style>
  @font-face {
    font-family: 'OumaBold';
    src: url('fonts/OumaTrial-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
  }
  @font-face {
    font-family: 'OumaLight';
    src: url('fonts/OumaTrial-Light.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
  }

  html, body {
    font-family: 'OumaLight', sans-serif;
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    min-height: 100vh;
    box-sizing: border-box;
    background-color: #000;
    overflow: hidden;
  }
  *, *:before, *:after {
    box-sizing: inherit;
  }
  #app-wrapper {
    position: relative;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  #controls {
    position: static;
    width: 100%;
    padding: 10px;
    box-sizing: border-box;
    background-color: #000; /* solid black */
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
    color: white;
    border-bottom: 1px solid #222;
    transition: none;
  }
  #controls.hidden {
    opacity: 1;
    pointer-events: auto;
  }
  #controls select,
  #controls button {
    font-size: 0.8rem;
    height: 28px;
    min-height: 28px;
    display: inline-flex;
    align-items: center;
    vertical-align: middle;
    border-radius: 4px;
    /* border: 1px solid #ccc; */
    padding: 5px;
  }
  #fullscreen-btn,
  #switch-server-btn,
  #server-select {
    font-family: 'OumaLight', sans-serif;
    background-color: #000;
    color: #222;
    border: 1px solid #222;
    border-radius: 4px;
    padding: 5px 12px;
    cursor: pointer;
  }
  #switch-server-btn {
    min-width: 110px;
    padding-left: 16px;
    padding-right: 16px;
  }
  #fullscreen-btn:hover,
  #switch-server-btn:hover {
    background-color: #96509a;
  }
  #main-layout {
    display: flex;
    flex: 1;
    height: calc(100vh - 48px);
    width: 100vw;
  }
  #player-section {
    position: relative;
    width: 70%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  #player-container {
    position: relative;
    width: 100%;
    height: 100%;
    flex: 1;
    overflow: hidden;
    z-index: 1;
  }
  #player-iframe, #player-video {
    width: 100%;
    height: 100%;
    border: none;
    z-index: 1;
    background: #000;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
  }
  #player-iframe.active, #player-video.active {
    display: block;
  }
  #menu-section {
    position: relative; /* Needed for overlay positioning */
    width: 30%;
    height: 100%; /* <-- Add this */
    display: flex; /* <-- Add this */
    flex-direction: column; /* <-- Add this */
    color: white;
    overflow-y: auto;
    border-left: 1px solid #222;
  }

  /* make menu-content the positioning context for the overlay
     so the overlay's height follows the whole scrollable content */
  #menu-content {
    position: relative;
    transition: filter 0.5s;
  }

  /* overlay that covers the entire menu content height (and will scroll with it) */
  #menu-content .menu-overlay {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 100%;                /* match full content height */
    background: rgba(0,0,0,0.90);
    pointer-events: none;
    opacity: 0;
    transition: opacity 1s;
    z-index: 100;
  }

  /* show overlay when menu-section has overlay-active */
  #menu-section.overlay-active #menu-content .menu-overlay {
    opacity: 1;
  }

  /* keep greyscale rule intact */
  #menu-section.overlay-active #menu-content {
    filter: grayscale(1);
  }

  /* Custom scrollbar for #menu-section */
  #menu-section::-webkit-scrollbar {
    width: 8px;
    background: transparent;
  }

  #menu-section::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.15); /* transparent white */
    border-radius: 4px;
  }

  #menu-section::-webkit-scrollbar-button {
    display: none; /* hides arrows */
  }

  /* For Firefox */
  #menu-section {
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.15) transparent;
  }

  #channel-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 8px;
    padding: 10px;
  }

  .channel-item {
    padding: 12px 8px;
    border: 1px solid #222;
    border-radius: 6px;
    background: rgba(255,255,255,0.06);
    cursor: pointer;
    text-align: center;
    font-size: 1em;
    min-height: 120px;           /* Set a fixed minimum height */
    height: 120px;               /* Set a fixed height for all tiles */
    display: flex;
    flex-direction: column;      /* Stack logo and title vertically */
    align-items: center;
    justify-content: center;
    transition: background 0.2s, color 0.2s;
    color: #fff;
    font-family: 'OumaBold', sans-serif;
    box-shadow: 0 1px 2px rgba(0,0,0,0.07);
  }
  .channel-item:hover {
    background-color: #96509a;
    color: #fff;
  }
  .channel-item.active {
    background-color: rgba(255, 255, 255, 0.2);
    color: #fff;
  }

  h2, #current-channel-name {
    font-family: 'OumaBold', sans-serif;
    font-size: 1.2em;
  }

  .channel-item img {
    width: 100%;
    max-width: 100%;
    max-height: 60px;
    height: auto;
    display: block;
    margin: 0 auto 6px auto;
    object-fit: contain;
  }

  body.hide-cursor {
    cursor: none !important;
  }

  /* Ensure children (tiles, buttons, svgs, inputs, etc.) also hide the cursor.
     This overrides .channel-item { cursor: pointer } while hide-cursor is active. */
  body.hide-cursor,
  body.hide-cursor * {
    cursor: none !important;
  }
  body.hide-cursor .keep-cursor { cursor: default !important; }

  /* Loading / splash video */
  #loading-video {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 9999;
    background: #000;
    display: block;
    opacity: 1;
    transition: opacity 0.5s ease;
    pointer-events: none; /* allow clicks through if needed */
  }

  /* Overlay to cover the injected top-right icon inside cross-origin iframe players (e.g. directfr).
     Adjust top/right/width/height if positioning needs fine-tuning. */
  #player-container .iframe-blocker {
    position: absolute;
    top: 0;
    right: 0;
    width: 67px;
    height: 40px;
    background: #000;     /* match player background so the icon is visually hidden */
    z-index: 9999;        /* above the iframe */
    pointer-events: auto; /* capture clicks so the icon can't be interacted with */
  }

  /* Server indicators */
  #server-indicators {
    display: none;
    align-items: center;
    gap: 6px;
    margin-right: 4px;
  }
  #server-indicators .indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #222;
    cursor: pointer;
    transition: background .2s, transform .2s, box-shadow .2s;
  }
  #server-indicators .indicator.active {
    background: #29c742;
    box-shadow: 0 0 4px #29c742;
  }
  #server-indicators .indicator:hover {
    transform: scale(1.3);
  }

  /* Inactivity dim (when channel menu overlay shows) */
  body.overlay-dim #server-indicators .indicator {
    background: #444;
    box-shadow: none;
    filter: grayscale(1) brightness(.75);
  }
  body.overlay-dim #server-indicators .indicator.active {
    background: #666;
  }

  /* Volume OSD */
  #volume-osd {
    position: absolute;
    bottom: 18px;
    left: 18px;
    background: rgba(0,0,0,0.55);
    color: #fff;
    font-family: 'OumaBold', sans-serif;
    padding: 6px 10px;
    border-radius: 6px;
    font-size: 0.85rem;
    letter-spacing: .5px;
    opacity: 0;
    pointer-events: none;
    transition: opacity .25s;
    z-index: 5000;
  }
  #volume-osd.show {
    opacity: 1;
  }
</style>
</head>
<body>
<div id="app-wrapper">
  <!-- loading splash video (plays once then removed) -->
  <video id="loading-video" src="assets/v2_background_tv_.mp4" autoplay muted playsinline preload="auto"></video>

  <div id="main-layout">
    <div id="player-section">
      <div id="controls">
        <div style="display:flex; align-items:center; flex:1;">
          <img src="assets/ateaish_tv_blanc_150ppi_noborder.png" alt="ateaish TV" style="height:32px; margin-right:16px;">
        </div>
        <div style="flex:2; text-align:center;">
          <div id="current-channel-name" style="font-weight:bold; font-size:1.2em; display:inline-block;"></div>
        </div>
        <div style="display:flex; align-items:center; flex:1; justify-content:flex-end; gap:10px;">
          <div id="server-indicators"></div>
          <!-- Removed server-select dropdown -->
          <button id="switch-server-btn" style="display: none;">Switch Server</button>
          <button id="fullscreen-btn">
            Fullscreen
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" style="vertical-align:middle; margin-left:6px;" class="bi bi-fullscreen" viewBox="0 0 16 16" stroke="#222" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5M.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5m15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5"/>
            </svg>
          </button>
        </div>
      </div>
      <div id="player-container">
        <iframe id="player-iframe" allow="fullscreen" allowfullscreen></iframe>
        <video id="player-video" controls autoplay playsinline></video>
        <div id="volume-osd"></div>
      </div>
    </div>
    <div id="menu-section">
      <div id="menu-content">
        <div class="menu-overlay"></div>
        <h2 style="color:white; margin:15px; display: flex; align-items: center; justify-content: space-between;">
          <span style="flex:0 0 auto;">Channels</span>
          <div style="display: flex; align-items: center; gap: 10px; flex: 0 0 auto;">
            <!-- Removed the visible 'Sports' text span -->
            <button id="sports-toggle-btn" title="Show only Sports channels"
              style="background: none; border: none; cursor: pointer; padding: 0; display:none;">
              <span id="sports-toggle-icon" class="keep-cursor">
                <!-- Default: toggle-off SVG -->
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="#96509a" class="bi bi-toggle-off" viewBox="0 0 16 16">
                  <path d="M11 4a4 4 0 0 1 0 8H8a5 5 0 0 0 2-4 5 5 0 0 0-2-4zm-6 8a4 4 0 1 1 0-8 4 4 0 0 1 0 8M0 8a5 5 0 0 0 5 5h6a5 5 0 0 0 0-10H5a5 5 0 0 0-5 5"/>
                </svg>
              </span>
            </button>
          </div>
          <div style="flex:0 0 auto; margin-left:auto;">
            <select id="country-select"
              style="
                font-family: 'OumaLight', sans-serif;
                background-color: #000;
                color: #FFF;
                border: 1px solid #222;
                border-radius: 4px;
                padding: 5px 12px;
                cursor: pointer;
                font-size: 1em;
                min-width: 110px;
                margin-left: 0;
              ">
              <option value="France" selected>France</option>
              <option value="UK">UK</option>
              <!-- Add more countries as needed -->
            </select>
          </div>
        </h2>
        <div id="channel-list"></div>
      </div>
    </div>
  </div>
</div>
<script>
  const controls = document.getElementById('controls');
  const playerIframe = document.getElementById('player-iframe');
  let playerVideo = document.getElementById('player-video');
  const witvBaseUrl = 'https://witv.soccer/player/playerjs/witv-player.php?id=';
  const tutvliveBaseUrl = 'https://tutvlive.ru/player/';
  const directfrBaseUrl = 'https://directfr.lat/player/player.php?id=';

  const fullscreenBtn = document.getElementById('fullscreen-btn');
  const switchServerBtn = document.getElementById('switch-server-btn');
  const countrySelect = document.getElementById('country-select');

  let channels = [];
  let player;
  let currentChannelIndex = 0;
  let currentFlattenedIndex = 0;
  let flattenedSources = [];

  let m3u8Timeout = null;
  let m3u8Tried = false;
  let bufferCleanupInterval = null;

  // HLS / DASH tuning constants (retuned for smoother playback + low RAM)
  // Back buffer kept small to reduce memory, forward buffer moderately larger for stability.
  const HLS_BACK_BUFFER_SECONDS = 12;   // how much history to retain (lower = less RAM)
  const HLS_MAX_BUFFER_LENGTH = 75;     // target forward buffer (was 60)
  const HLS_MAX_MAX_BUFFER_LENGTH = 140; // absolute cap (was 120)
  const HLS_INITIAL_BUFFER_LENGTH = 30; // initial cap before adaptive growth
  const HLS_MAX_BUFFER_SIZE_BYTES = 55 * 1000 * 1000; // ~55MB safety cap

  // If you want to be defensive (avoid redefinition), you could wrap:
  // window.HLS_BACK_BUFFER_SECONDS ??= 30;

  // ADD: playback helper state & functions
  let hlsInstance = null;
  let dashPlayer = null;

  function cleanupPlayers() {
    if (m3u8Timeout) { clearTimeout(m3u8Timeout); m3u8Timeout = null; }
    if (bufferCleanupInterval) { clearInterval(bufferCleanupInterval); bufferCleanupInterval = null; }

    // HLS
    if (hlsInstance) {
      try { hlsInstance.destroy(); } catch(_) {}
      hlsInstance = null;
    }
    // DASH
    if (dashPlayer) {
      try { dashPlayer.reset(); } catch(_) {}
      dashPlayer = null;
    }
    // HTML5 video
    if (playerVideo) {
      try {
        playerVideo.pause();
        playerVideo.removeAttribute('src');
        playerVideo.load();
      } catch(_) {}
      playerVideo.classList.remove('active');
      playerVideo.style.display = 'none';
    }
    // Iframe
    if (playerIframe) {
      playerIframe.classList.remove('active');
      playerIframe.style.display = 'none';
      // Stop previous iframe stream (blank it)
      try { playerIframe.src = 'about:blank'; } catch(_) {}
    }
    player = null;
  }

  function addPlayerListeners() {
    // Optional placeholder for uniform interface
    // Extend if you need events (play/pause/error) later.
  }

  function initHls(url) {
    cleanupStreamOnly('hls');
    const cfg = {
      backBufferLength: HLS_BACK_BUFFER_SECONDS,
      maxBufferLength: HLS_INITIAL_BUFFER_LENGTH,
      maxMaxBufferLength: HLS_MAX_MAX_BUFFER_LENGTH,
      maxBufferSize: HLS_MAX_BUFFER_SIZE_BYTES,
      liveSyncDuration: 4,
      liveMaxLatencyDuration: 18,
      liveDurationInfinity: true,
      enableWorker: true,
      lowLatencyMode: false,
      fragLoadingTimeOut: 20000,
      manifestLoadingTimeOut: 15000
    };
    hlsInstance = new Hls(cfg);

    let stallCount = 0;

    function attemptAutoplay(retryDelay = 600, retries = 3) {
      const p = playerVideo.play();
      if (p && p.catch) {
        p.catch(() => {
          if (retries > 0) {
            setTimeout(() => attemptAutoplay(retryDelay, retries - 1), retryDelay);
          }
        });
      }
    }

    function disableAllTextTracks() {
      if (!playerVideo || !playerVideo.textTracks) return;
      for (const track of playerVideo.textTracks) {
        track.mode = 'disabled';
      }
    }

    hlsInstance.on(Hls.Events.LEVEL_LOADED, () => {
      if (hlsInstance.config.maxBufferLength < HLS_MAX_BUFFER_LENGTH) {
        hlsInstance.config.maxBufferLength = HLS_MAX_BUFFER_LENGTH;
      }
    });

    hlsInstance.on(Hls.Events.MANIFEST_PARSED, () => {
      // Disable Hls.js subtitle tracks if any
      try {
        if (hlsInstance.subtitleTracks && hlsInstance.subtitleTracks.length) {
          hlsInstance.subtitleTrack = -1; // no subtitle
        }
      } catch(_) {}
      // Also disable any native text tracks
      disableAllTextTracks();
      attemptAutoplay();
    });

    hlsInstance.on(Hls.Events.BUFFER_STALLED, () => {
      stallCount++;
      if (stallCount <= 4) {
        const cur = hlsInstance.config.maxBufferLength;
        const next = Math.min(cur + 10, HLS_MAX_MAX_BUFFER_LENGTH);
        hlsInstance.config.maxBufferLength = next;
      }
    });

    hlsInstance.on(Hls.Events.ERROR, (_, data) => {
      if (data.fatal) {
        switch (data.type) {
          case Hls.ErrorTypes.NETWORK_ERROR:
            hlsInstance.startLoad();
            break;
          case Hls.ErrorTypes.MEDIA_ERROR:
            hlsInstance.recoverMediaError();
            break;
          default:
            tryNextSource();
        }
      }
    });

    hlsInstance.loadSource(url);
    hlsInstance.attachMedia(playerVideo);
    // Early attempt before manifest (some browsers allow it)
    attemptAutoplay(800, 2);
  }

  function initDash(url) {
    if (dashPlayer) { try { dashPlayer.reset(); } catch(_) {} dashPlayer = null; }
    dashPlayer = dashjs.MediaPlayer().create();
    dashPlayer.updateSettings({
      'streaming': {
        'fastSwitchEnabled': true,
        'abr': {
          'autoSwitchBitrate': { 'video': true },
          'limitBitrateByPortal': true,
          'initialBitrate': { 'video': 2800 }
        },
        'buffer': {
          // Stable forward buffer; dash.js internally evicts behind current time.
          'stableBufferTime': 22,
          'bufferTimeAtTopQuality': 32,
          'bufferToKeep': 12   // back buffer retention (smaller = lower RAM)
        },
        'liveDelay': 6
      }
    });
    dashPlayer.initialize(playerVideo, url, true);
  }

  function cleanupStreamOnly(type) {
    if (type === 'hls' && hlsInstance) {
      try { hlsInstance.destroy(); } catch(_) {}
      hlsInstance = null;
    }
    if (type === 'dash' && dashPlayer) {
      try { dashPlayer.reset(); } catch(_) {}
      dashPlayer = null;
    }
  }

  fetch('channels/France.json')
    .then(response => response.json())
    .then(data => {
      channels = data;
      populateChannelList();
      updatePlayer(currentChannelIndex);
      player = new playerjs.Player(playerIframe);
      addPlayerListeners();
    });

  // Dynamically populate country menu from channels folder
  function populateCountryMenu() {
    fetch('channels/index.json')
      .then(response => response.json())
      .then(files => {
        // files should be an array of filenames like ["France.json", "Germany.json", ...]
        countrySelect.innerHTML = '';
        files.forEach(file => {
          const country = file.replace('.json', '');
          const option = document.createElement('option');
          option.value = country;
          option.textContent = country;
          if (country === 'France') option.selected = true;
          countrySelect.appendChild(option);
        });
      });
  }

  // Call this on page load
  populateCountryMenu();

  countrySelect.addEventListener('change', (event) => {
    const country = event.target.value;
    fetch(`channels/${country}.json`)
      .then(response => response.json())
      .then(data => {
        channels = data;
        currentChannelIndex = 0;
        populateChannelList();
        updatePlayer(currentChannelIndex);
      });
  });

  function sanitizeChannelName(name) {
    // Remove accents, replace spaces and special chars for file path
    return name
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // remove accents
      .replace(/[^a-zA-Z0-9]/g, "_"); // replace non-alphanum with _
  }

  // --- Sports toggle logic ---
  let sportsOnly = false;
  const sportsToggleBtn = document.getElementById('sports-toggle-btn');
  const sportsToggleIcon = document.getElementById('sports-toggle-icon');

  // NEW: robust sports detector
  function isSportsChannel(channel) {
    const candidates = [];

    // Collect possible fields
    if (channel.category !== undefined) candidates.push(channel.category);
    if (channel.categories !== undefined) candidates.push(channel.categories);
    if (channel.genre !== undefined) candidates.push(channel.genre);
    if (channel.genres !== undefined) candidates.push(channel.genres);
    if (channel.tags !== undefined) candidates.push(channel.tags);

    // Flatten & normalize
    const tokens = [];
    candidates.forEach(entry => {
      if (entry == null) return;
      if (Array.isArray(entry)) {
        entry.forEach(v => {
          if (v == null) return;
            // Support objects like { name: "Sports" }
            if (typeof v === 'object') {
              if (v.name) tokens.push(String(v.name));
            } else {
              tokens.push(String(v));
            }
        });
      } else if (typeof entry === 'object') {
        // Object with name
        if (entry.name) tokens.push(String(entry.name));
      } else if (typeof entry === 'string') {
        // Split on common delimiters
        entry.split(/[,;/|]/).forEach(part => tokens.push(part));
      } else {
        tokens.push(String(entry));
      }
    });

    const normalized = tokens
      .map(t => t.toLowerCase().trim())
      .filter(Boolean);

    // Direct exact matches
    if (normalized.some(t => t === 'sport' || t === 'sports')) return true;

    // Substring fallback (avoid false positives like "Esports" unless you want it)
    if (normalized.some(t => /\bsports?\b/.test(t))) return true;

    return false;
  }

  function updateSportsToggleIcon() {
    sportsToggleIcon.innerHTML = sportsOnly
      ? `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="#96509a" class="bi bi-toggle-on" viewBox="0 0 16 16">
          <path d="M5 3a5 5 0 0 0 0 10h6a5 5 0 0 0 0-10zm6 9a4 4 0 1 1 0-8 4 4 0 0 1 0 8"/>
        </svg>`
      : `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="#96509a" class="bi bi-toggle-off" viewBox="0 0 16 16">
          <path d="M11 4a4 4 0 0 1 0 8H8a5 5 0 0 0 2-4 5 5 0 0 0-2-4zm-6 8a4 4 0 1 1 0-8 4 4 0 0 1 0 8M0 8a5 5 0 0 0 5 5h6a5 5 0 0 0 0-10H5a5 5 0 0 0-5 5"/>
        </svg>`;
  }

  sportsToggleBtn.addEventListener('click', () => {
    sportsOnly = !sportsOnly;
    updateSportsToggleIcon();
    populateChannelList();
  });

  function populateChannelList() {
    const channelList = document.getElementById('channel-list');
    channelList.innerHTML = '';
    let filteredChannels = channels;
    if (sportsOnly) {
      filteredChannels = channels.filter(isSportsChannel);
    }
    filteredChannels.forEach((channel, index) => {
      const div = document.createElement('div');
      div.className = 'channel-item';
      div.onclick = () => {
        const realIndex = channels.indexOf(channel);
        updatePlayer(realIndex);
      };

      const logoPath = channel.logo
        ? channel.logo
        : `/logos/${sanitizeChannelName(channel.name)}.png`;

      if (channel.logo || logoPath.endsWith('.png')) {
        const img = document.createElement('img');
        img.src = logoPath;
        img.alt = channel.name + " logo";
        img.style.maxWidth = "80px";
        img.style.maxHeight = "60px";
        img.style.display = "block";
        img.style.margin = "0 auto 6px auto";
        img.onerror = function() {
          this.style.display = "none";
          if (!div.querySelector('.channel-title')) {
            const nameDiv = document.createElement('div');
            nameDiv.textContent = channel.name;
            nameDiv.className = 'channel-title';
            nameDiv.style.fontSize = "0.95em";
            nameDiv.style.wordBreak = "break-word";
            div.appendChild(nameDiv);
          }
        };
        div.appendChild(img);
      }

      if (!channel.logo && (!logoPath || logoPath === '/logos/undefined.png')) {
        const nameDiv = document.createElement('div');
        nameDiv.textContent = channel.name;
        nameDiv.className = 'channel-title';
        nameDiv.style.fontSize = "0.95em";
        nameDiv.style.wordBreak = "break-word";
        div.appendChild(nameDiv);
      }

      channelList.appendChild(div);
    });
  }

  // Build flattened list of all playable links for a channel
  function flattenSources(channel) {
    const flat = [];
    if (!channel || !Array.isArray(channel.sources)) return flat;
    channel.sources.forEach(src => {
      if (Array.isArray(src.servers) && src.servers.length > 0) {
        src.servers.forEach((_, idx) => {
          flat.push({ source: src, serverIdx: idx, type: src.type });
        });
      } else {
        flat.push({ source: src, serverIdx: 0, type: src.type });
      }
    });
    return flat;
  }

  const serverIndicators = document.getElementById('server-indicators');

  function updateServerIndicators() {
    serverIndicators.innerHTML = '';
    if (!flattenedSources || flattenedSources.length < 2) {
      serverIndicators.style.display = 'none';
      return;
    }
    serverIndicators.style.display = 'flex';
    flattenedSources.forEach((entry, idx) => {
      const dot = document.createElement('span');
      dot.className = 'indicator' + (idx === currentFlattenedIndex ? ' active' : '');
      dot.title = `Link ${idx + 1} (${entry.type}${entry.source.servers && entry.source.servers.length > 1 ? ' S'+(entry.serverIdx+1) : ''})`;
      dot.addEventListener('click', () => {
        if (idx === currentFlattenedIndex) return;
        playFlattenedIndex(idx);
      });
      serverIndicators.appendChild(dot);
    });
  }

  function cycleNextFlattened() {
    if (!flattenedSources.length) return;
    const next = (currentFlattenedIndex + 1) % flattenedSources.length;
    playFlattenedIndex(next);
  }

  // Replace old tryNextSource with flattened fallback
  function tryNextSource() {
    cycleNextFlattened();
  }

  function playFlattenedIndex(flatIndex) {
    currentFlattenedIndex = flatIndex;
    const entry = flattenedSources[flatIndex];
    if (!entry) return;
    const { source, serverIdx, type } = entry;
    playSourceObject(source, type, serverIdx);
    updateServerIndicators();
  }

  // Main channel load (rebuild flattened list then play first or keep index if possible)
  function updatePlayer(channelIndex, preservedFlatIndex = 0) {
    currentChannelIndex = channelIndex;
    const channel = channels[currentChannelIndex];
    document.getElementById('current-channel-name').textContent = channel ? channel.name : '';
    if (!channel) return;

    flattenedSources = flattenSources(channel);
    if (!flattenedSources.length) return;

    // Clamp preserved index
    if (preservedFlatIndex >= flattenedSources.length) preservedFlatIndex = 0;
    playFlattenedIndex(preservedFlatIndex);
    populateChannelList(); // keep highlighting logic consistent
  }

  // Core playback logic (adapted from previous branches)
  function playSourceObject(source, sourceType, serverIdx = 0) {
    cleanupPlayers();

    let url;
    if (sourceType === 'iframe') {
      url = source.url;
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = url;
      player = { play:()=>{}, pause:()=>{}, getPaused:cb=>cb(false), mute:()=>{}, unmute:()=>{}, getMuted:cb=>cb(false) };
      addPlayerListeners();
    } else if (sourceType === 'witv') {
      url = witvBaseUrl + source.id + '&q=1080';
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = url;
      setTimeout(() => {
        player = new playerjs.Player(playerIframe);
        addPlayerListeners();
        player.play(); player.unmute();
      }, 500);
    } else if (sourceType === 'tutvlive') {
      const server = (source.servers && source.servers[serverIdx]) || (source.servers && source.servers[0]);
      url = `${tutvliveBaseUrl}${server}/${source.id}`;
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = url;
      setTimeout(() => {
        player = new playerjs.Player(playerIframe);
        addPlayerListeners();
        player.play(); player.unmute();
      }, 500);
    } else if (sourceType === 'm3u8') {
      url = source.url || source;
      playerVideo.classList.add('active');
      playerVideo.style.display = 'block';
      if (Hls.isSupported()) {
        initHls(url);
      } else if (playerVideo.canPlayType('application/vnd.apple.mpegurl')) {
        playerVideo.src = url;
        // Disable native (Safari) text tracks once metadata is ready
        playerVideo.addEventListener('loadedmetadata', () => {
          if (playerVideo.textTracks) {
            for (const t of playerVideo.textTracks) t.mode = 'disabled';
          }
          playerVideo.play().catch(()=>{ setTimeout(()=>playerVideo.play().catch(()=>{}), 600); });
        }, { once: true });
        // Fallback immediate attempt + proactive track disable (in case tracks already present)
        if (playerVideo.textTracks) {
          for (const t of playerVideo.textTracks) t.mode = 'disabled';
        }
        playerVideo.play().catch(()=>{ setTimeout(()=>playerVideo.play().catch(()=>{}), 600); });
      }
      m3u8Timeout = setTimeout(() => {
        if (playerVideo.paused && !m3u8Tried) {
          m3u8Tried = true;
          tryNextSource();
        }
      }, 10000);
      player = {
        play: () => playerVideo.play(),
        pause: () => playerVideo.pause(),
        getPaused: cb => cb(playerVideo.paused),
        mute: () => { playerVideo.muted = true; },
        unmute: () => { playerVideo.muted = false; },
        getMuted: cb => cb(playerVideo.muted)
      };
      addPlayerListeners();
      player.unmute();
    } else if (sourceType === 'mpd') {
      url = source.url || source;
      playerVideo.classList.add('active');
      playerVideo.style.display = 'block';
      initDash(url);
      player = {
        play: () => playerVideo.play(),
        pause: () => playerVideo.pause(),
        getPaused: cb => cb(playerVideo.paused),
        mute: () => { playerVideo.muted = true; },
        unmute: () => { playerVideo.muted = false; },
        getMuted: cb => cb(playerVideo.muted)
      };
      addPlayerListeners();
      player.unmute();
    } else if (sourceType === 'directfr') {
      url = directfrBaseUrl + source.id;
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = url;
      setTimeout(() => {
        player = new playerjs.Player(playerIframe);
        addPlayerListeners();
        player.play(); player.unmute();
      }, 500);
    } else if (sourceType === 'daddylive' && source.channel_id) {
      const streamUrl = `https://dlhd.dad/stream/stream-${source.channel_id}.php`;
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = streamUrl;
      playerIframe.setAttribute('allowfullscreen', 'true');
      playerIframe.setAttribute('loading', 'lazy');
      return;
    }

    // Always show single unified button
    switchServerBtn.textContent = 'Switch Server';
    switchServerBtn.style.display = flattenedSources.length > 1 ? 'inline-block' : 'none';
  }

  // Button: cycle to next flattened link
  switchServerBtn.addEventListener('click', () => {
    cycleNextFlattened();
  });

  // --- Overlay logic for menu-section ---
  const menuSection = document.getElementById('menu-section');
  let overlayTimeout;

  function showMenuOverlay() {
    menuSection.classList.add('overlay-active');
    document.body.classList.add('overlay-dim');   // dim server indicators
  }
  function hideMenuOverlay() {
    menuSection.classList.remove('overlay-active');
    document.body.classList.remove('overlay-dim'); // restore indicators
  }
  function resetMenuOverlayTimer() {
    hideMenuOverlay();
    if (overlayTimeout) clearTimeout(overlayTimeout);
    overlayTimeout = setTimeout(showMenuOverlay, 5000);
  }

  // Controls logic
  let hideTimeout;
  function showControls() {
    controls.classList.remove('hidden');
    clearTimeout(hideTimeout);
    hideTimeout = setTimeout(() => {
      controls.classList.add('hidden');
      showMenuOverlay();
    }, 5000);
    hideMenuOverlay();
  }

  // Mouse cursor hide logic
  let cursorTimeout;

  // central setter that toggles both the CSS class and explicit element cursor styles
  function setCursorHidden(hidden) {
    document.body.classList.toggle('hide-cursor', hidden);
    const value = hidden ? 'none' : '';
    // apply explicit cursor style to elements that can otherwise show it (iframe/video/controls/menu)
    document.body.style.cursor = value;
    if (playerIframe) playerIframe.style.cursor = value;
    if (playerVideo) playerVideo.style.cursor = value;
    if (controls) controls.style.cursor = value;
    if (menuSection) menuSection.style.cursor = value;
    // also try the root element
    document.documentElement.style.cursor = value;
  }

  function showCursor() {
    // show immediately and restart hide timer
    setCursorHidden(false);
    if (cursorTimeout) clearTimeout(cursorTimeout);
    cursorTimeout = setTimeout(() => {
      setCursorHidden(true);
    }, 5000);
  }

  // Listen for mouse movement to reset all timers
  document.addEventListener('mousemove', () => {
    resetMenuOverlayTimer();
    showControls();
    showCursor();
  });

  // Start timers on load
  resetMenuOverlayTimer();
  showControls();
  showCursor();

  // Loading-screen logic: remove the loading video after it plays once
  (function() {
    const loadingVideo = document.getElementById('loading-video');
    if (!loadingVideo) return;

    // Ensure playsInline & muted for autoplay policies
    loadingVideo.muted = true;
    loadingVideo.playsInline = true;

    // Try to play (some environments require explicit play())
    loadingVideo.play().catch(() => { /* ignore autoplay rejection */ });

    function removeLoadingVideo() {
      if (!loadingVideo.parentNode) return;
      loadingVideo.style.opacity = '0';
      setTimeout(() => {
        if (loadingVideo.parentNode) loadingVideo.parentNode.removeChild(loadingVideo);
      }, 600);
    }

    loadingVideo.addEventListener('ended', removeLoadingVideo, { once: true });

    // Fallback: remove after a maximum duration in case 'ended' doesn't fire
    const MAX_FALLBACK_MS = 30000;
    setTimeout(() => {
      if (document.getElementById('loading-video')) removeLoadingVideo();
    }, MAX_FALLBACK_MS);

    // Optional: allow click to skip the loading video (unobtrusive)
    loadingVideo.addEventListener('click', removeLoadingVideo);
  })();

  // --- Fullscreen support (added) ---
  function isFullscreen() {
    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);
  }
  function requestAnyFullscreen(el) {
    (el.requestFullscreen ||
     el.webkitRequestFullscreen ||
     el.msRequestFullscreen ||
     el.mozRequestFullScreen)?.call(el);
  }
  function exitAnyFullscreen() {
    (document.exitFullscreen ||
     document.webkitExitFullscreen ||
     document.msExitFullscreen ||
     document.mozCancelFullScreen)?.call(document);
  }
  function toggleFullscreen() {
    if (isFullscreen()) {
      exitAnyFullscreen();
    } else {
      // Prefer making the player section fullscreen; fallback to documentElement
      const target = document.getElementById('player-section') || document.documentElement;
      requestAnyFullscreen(target);
    }
  }
  fullscreenBtn.addEventListener('click', toggleFullscreen);

  // Optional: update button label/state
  function updateFullscreenButton() {
    if (!fullscreenBtn) return;
    // Keep icon; just adjust text before it if desired
    // Assuming firstChild is a text node "Fullscreen"
    if (isFullscreen()) {
      fullscreenBtn.firstChild && (fullscreenBtn.firstChild.textContent = 'Exit Fullscreen ');
    } else {
      fullscreenBtn.firstChild && (fullscreenBtn.firstChild.textContent = 'Fullscreen ');
    }
  }
  ['fullscreenchange','webkitfullscreenchange','msfullscreenchange','mozfullscreenchange']
    .forEach(evt => document.addEventListener(evt, updateFullscreenButton));
</script>
</body>
</html>
