<!DOCTYPE html>
<html>
<head>
<title>ateaish TV</title>
<link rel="icon" type="image/png" href="assets/favicon_tv_150ppi.png">
<script type="text/javascript" src="https://cdn.embed.ly/player-0.1.0.min.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script type="text/javascript" src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
<style>
  @font-face {
    font-family: 'OumaBold';
    src: url('fonts/OumaTrial-Bold.ttf') format('truetype');
    font-weight: bold;
    font-style: normal;
  }
  @font-face {
    font-family: 'OumaLight';
    src: url('fonts/OumaTrial-Light.ttf') format('truetype');
    font-weight: normal;
    font-style: normal;
  }

  html, body {
    font-family: 'OumaLight', sans-serif;
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    min-height: 100vh;
    box-sizing: border-box;
    background-color: #000;
    overflow: hidden;
  }
  *, *:before, *:after {
    box-sizing: inherit;
  }
  #app-wrapper {
    position: relative;
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  #controls {
    position: static;
    width: 100%;
    padding: 10px;
    box-sizing: border-box;
    background-color: #000; /* solid black */
    z-index: 10;
    display: flex;
    align-items: center;
    gap: 10px;
    color: white;
    border-bottom: 1px solid #222;
    transition: none;
  }
  #controls.hidden {
    opacity: 1;
    pointer-events: auto;
  }
  #controls select,
  #controls button {
    font-size: 0.8rem;
    height: 28px;
    min-height: 28px;
    display: inline-flex;
    align-items: center;
    vertical-align: middle;
    border-radius: 4px;
    /* border: 1px solid #ccc; */
    padding: 5px;
  }
  #fullscreen-btn,
  #switch-server-btn,
  #server-select {
    font-family: 'OumaLight', sans-serif;
    background-color: #000;
    color: #222;
    border: 1px solid #222;
    border-radius: 4px;
    padding: 5px 12px;
    cursor: pointer;
  }
  #switch-server-btn {
    min-width: 110px;
    padding-left: 16px;
    padding-right: 16px;
  }
  #fullscreen-btn:hover,
  #switch-server-btn:hover {
    background-color: #96509a;
  }
  #main-layout {
    display: flex;
    flex: 1;
    height: calc(100vh - 48px);
    width: 100vw;
  }
  #player-section {
    position: relative;
    width: 70%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  #player-container {
    position: relative;
    width: 100%;
    height: 100%;
    flex: 1;
    overflow: hidden;
    z-index: 1;
  }
  #player-iframe, #player-video {
    width: 100%;
    height: 100%;
    border: none;
    z-index: 1;
    background: #000;
    display: none;
    position: absolute;
    top: 0;
    left: 0;
  }
  #player-iframe.active, #player-video.active {
    display: block;
  }
  #menu-section {
    position: relative; /* Needed for overlay positioning */
    width: 30%;
    height: 100%; /* <-- Add this */
    display: flex; /* <-- Add this */
    flex-direction: column; /* <-- Add this */
    color: white;
    overflow-y: auto;
    border-left: 1px solid #222;
  }

  /* make menu-content the positioning context for the overlay
     so the overlay's height follows the whole scrollable content */
  #menu-content {
    position: relative;
    transition: filter 0.5s;
  }

  /* overlay that covers the entire menu content height (and will scroll with it) */
  #menu-content .menu-overlay {
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 100%;                /* match full content height */
    background: rgba(0,0,0,0.90);
    pointer-events: none;
    opacity: 0;
    transition: opacity 1s;
    z-index: 100;
  }

  /* show overlay when menu-section has overlay-active */
  #menu-section.overlay-active #menu-content .menu-overlay {
    opacity: 1;
  }

  /* keep greyscale rule intact */
  #menu-section.overlay-active #menu-content {
    filter: grayscale(1);
  }

  /* Custom scrollbar for #menu-section */
  #menu-section::-webkit-scrollbar {
    width: 8px;
    background: transparent;
  }

  #menu-section::-webkit-scrollbar-thumb {
    background: rgba(255,255,255,0.15); /* transparent white */
    border-radius: 4px;
  }

  #menu-section::-webkit-scrollbar-button {
    display: none; /* hides arrows */
  }

  /* For Firefox */
  #menu-section {
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.15) transparent;
  }

  #channel-list {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 8px;
    padding: 10px;
  }

  .channel-item {
    padding: 12px 8px;
    border: 1px solid #222;
    border-radius: 6px;
    background: rgba(255,255,255,0.06);
    cursor: pointer;
    text-align: center;
    font-size: 1em;
    min-height: 120px;           /* Set a fixed minimum height */
    height: 120px;               /* Set a fixed height for all tiles */
    display: flex;
    flex-direction: column;      /* Stack logo and title vertically */
    align-items: center;
    justify-content: center;
    transition: background 0.2s, color 0.2s;
    color: #fff;
    font-family: 'OumaBold', sans-serif;
    box-shadow: 0 1px 2px rgba(0,0,0,0.07);
  }
  .channel-item:hover {
    background-color: #96509a;
    color: #fff;
  }
  .channel-item.active {
    background-color: rgba(255, 255, 255, 0.2);
    color: #fff;
  }

  h2, #current-channel-name {
    font-family: 'OumaBold', sans-serif;
    font-size: 1.2em;
  }

  .channel-item img {
    width: 100%;
    max-width: 100%;
    max-height: 60px;
    height: auto;
    display: block;
    margin: 0 auto 6px auto;
    object-fit: contain;
  }

  body.hide-cursor {
    cursor: none !important;
  }

  /* Ensure children (tiles, buttons, svgs, inputs, etc.) also hide the cursor.
     This overrides .channel-item { cursor: pointer } while hide-cursor is active. */
  body.hide-cursor,
  body.hide-cursor * {
    cursor: none !important;
  }
  body.hide-cursor .keep-cursor { cursor: default !important; }

  /* Loading / splash video */
  #loading-video {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: 9999;
    background: #000;
    display: block;
    opacity: 1;
    transition: opacity 0.5s ease;
    pointer-events: none; /* allow clicks through if needed */
  }

  /* Overlay to cover the injected top-right icon inside cross-origin iframe players (e.g. directfr).
     Adjust top/right/width/height if positioning needs fine-tuning. */
  #player-container .iframe-blocker {
    position: absolute;
    top: 0;
    right: 0;
    width: 67px;
    height: 40px;
    background: #000;     /* match player background so the icon is visually hidden */
    z-index: 9999;        /* above the iframe */
    pointer-events: auto; /* capture clicks so the icon can't be interacted with */
  }
</style>
</head>
<body>
<div id="app-wrapper">
  <!-- loading splash video (plays once then removed) -->
  <video id="loading-video" src="assets/v2_background_tv_.mp4" autoplay muted playsinline preload="auto"></video>

  <div id="main-layout">
    <div id="player-section">
      <div id="controls">
        <div style="display:flex; align-items:center; flex:1;">
          <img src="assets/ateaish_tv_blanc_150ppi_noborder.png" alt="ateaish TV" style="height:32px; margin-right:16px;">
        </div>
        <div style="flex:2; text-align:center;">
          <div id="current-channel-name" style="font-weight:bold; font-size:1.2em; display:inline-block;"></div>
        </div>
        <div style="display:flex; align-items:center; flex:1; justify-content:flex-end; gap:10px;">
          <select id="server-select" style="display:none;"></select>
          <button id="switch-server-btn" style="display: none;">Switch Source</button>
          <button id="fullscreen-btn">
            Fullscreen
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" style="vertical-align:middle; margin-left:6px;" class="bi bi-fullscreen" viewBox="0 0 16 16" stroke="#222" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5M.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5m15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5"/>
            </svg>
          </button>
        </div>
      </div>
      <div id="player-container">
        <iframe id="player-iframe"></iframe>
        <video id="player-video" controls></video>
      </div>
    </div>
    <div id="menu-section">
      <div id="menu-content">
        <div class="menu-overlay"></div>
        <h2 style="color:white; margin:15px; display: flex; align-items: center; justify-content: space-between;">
          <span>Channels</span>
          <select id="country-select"
            style="
              font-family: 'OumaLight', sans-serif;
              background-color: #000;
              color: #FFF;
              border: 1px solid #222;
              border-radius: 4px;
              padding: 5px 12px;
              cursor: pointer;
              font-size: 1em;
              min-width: 110px;
              margin-left: 16px;
            ">
            <option value="France" selected>France</option>
            <option value="UK">UK</option>
            <!-- Add more countries as needed -->
          </select>
        </h2>
        <div id="channel-list"></div>
      </div>
    </div>
  </div>
</div>
<script>
  const controls = document.getElementById('controls');
  const playerIframe = document.getElementById('player-iframe');
  let playerVideo = document.getElementById('player-video');
  const witvBaseUrl = 'https://witv.soccer/player/playerjs/witv-player.php?id=';
  const tutvliveBaseUrl = 'https://tutvlive.ru/player/';
  const directfrBaseUrl = 'https://directfr.lat/player/player.php?id=';

  const fullscreenBtn = document.getElementById('fullscreen-btn');
  const switchServerBtn = document.getElementById('switch-server-btn');
  const serverSelect = document.getElementById('server-select');
  const countrySelect = document.getElementById('country-select');

  let channels = [];
  let player;
  let currentChannelIndex = 0;
  let currentSourceType = '';
  let currentServerIndex = 0;
  let m3u8Timeout = null;
  let m3u8Tried = false;
  let bufferCleanupInterval = null;

  // --- Added: HLS buffer control constants & helper ---
  const HLS_BACK_BUFFER_SECONDS = 60;        // keep last 60s behind playhead
  const HLS_MAX_BUFFER_LENGTH = 30;          // target forward buffer
  const HLS_MAX_MAX_BUFFER_LENGTH = 60;      // hard cap forward buffer

  function logApproxVideoBuffered() {
    if (!playerVideo) return;
    const ranges = playerVideo.buffered;
    let total = 0;
    for (let i = 0; i < ranges.length; i++) {
      total += (ranges.end(i) - ranges.start(i));
    }
    // console.debug('[Buffer]', total.toFixed(1) + 's');
  }

  fetch('channels/France.json')
    .then(response => response.json())
    .then(data => {
      channels = data;
      populateChannelList();
      updatePlayer(currentChannelIndex);
      player = new playerjs.Player(playerIframe);
      addPlayerListeners();
    });

  // Dynamically populate country menu from channels folder
  function populateCountryMenu() {
    fetch('channels/index.json')
      .then(response => response.json())
      .then(files => {
        // files should be an array of filenames like ["France.json", "Germany.json", ...]
        countrySelect.innerHTML = '';
        files.forEach(file => {
          const country = file.replace('.json', '');
          const option = document.createElement('option');
          option.value = country;
          option.textContent = country;
          if (country === 'France') option.selected = true;
          countrySelect.appendChild(option);
        });
      });
  }

  // Call this on page load
  populateCountryMenu();

  countrySelect.addEventListener('change', (event) => {
    const country = event.target.value;
    fetch(`channels/${country}.json`)
      .then(response => response.json())
      .then(data => {
        channels = data;
        currentChannelIndex = 0;
        populateChannelList();
        updatePlayer(currentChannelIndex);
      });
  });

  function sanitizeChannelName(name) {
    // Remove accents, replace spaces and special chars for file path
    return name
      .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // remove accents
      .replace(/[^a-zA-Z0-9]/g, "_"); // replace non-alphanum with _
  }

  function populateChannelList() {
    const channelList = document.getElementById('channel-list');
    channelList.innerHTML = '';
    channels.forEach((channel, index) => {
      const div = document.createElement('div');
      div.className = 'channel-item';
      div.onclick = () => {
        updatePlayer(index);
      };

      // Determine logo path
      const logoPath = channel.logo
        ? channel.logo
        : `/logos/${sanitizeChannelName(channel.name)}.png`;

      // Only add <img> if logo is present (not null/empty)
      if (channel.logo || logoPath.endsWith('.png')) {
        const img = document.createElement('img');
        img.src = logoPath;
        img.alt = channel.name + " logo";
        img.style.maxWidth = "80px";      // Increased width
        img.style.maxHeight = "60px";     // Optionally increase height
        img.style.display = "block";
        img.style.margin = "0 auto 6px auto";
        img.onerror = function() {
          this.style.display = "none";
          // Show name if logo fails to load and title not already present
          if (!div.querySelector('.channel-title')) {
            const nameDiv = document.createElement('div');
            nameDiv.textContent = channel.name;
            nameDiv.className = 'channel-title';
            nameDiv.style.fontSize = "0.95em";
            nameDiv.style.wordBreak = "break-word";
            div.appendChild(nameDiv);
          }
        };
        div.appendChild(img);
      }

      // If no logo, show title only once
      if (!channel.logo && (!logoPath || logoPath === '/logos/undefined.png')) {
        const nameDiv = document.createElement('div');
        nameDiv.textContent = channel.name;
        nameDiv.className = 'channel-title';
        nameDiv.style.fontSize = "0.95em";
        nameDiv.style.wordBreak = "break-word";
        div.appendChild(nameDiv);
      }

      channelList.appendChild(div);
    });
  }

  function populateServerSelect(servers) {
    serverSelect.innerHTML = '';
    servers.forEach((server, idx) => {
      const option = document.createElement('option');
      option.value = idx;
      option.textContent = 'Server ' + (idx + 1);
      serverSelect.appendChild(option);
    });
    serverSelect.style.display = servers.length > 1 ? 'inline-block' : 'none';
  }

  function tryNextSource(channelIndex, triedSources) {
    const channel = channels[channelIndex];
    const sources = channel.sources || [];
    // Priority: mpd, m3u8, directfr, tutvlive, witv
    let nextSource = null;
    if (!triedSources.includes('mpd')) {
      nextSource = sources.find(s => s.type === 'mpd' || (s.url && s.url.endsWith('.mpd')));
      if (nextSource) return updatePlayer(channelIndex, 'mpd', 0, triedSources.concat('mpd'));
    }
    if (!triedSources.includes('m3u8')) {
      nextSource = sources.find(s => s.type === 'm3u8' || (s.url && s.url.endsWith('.m3u8')));
      if (nextSource) return updatePlayer(channelIndex, 'm3u8', 0, triedSources.concat('m3u8'));
    }
    if (!triedSources.includes('directfr')) {
      nextSource = sources.find(s => s.type === 'directfr');
      if (nextSource) return updatePlayer(channelIndex, 'directfr', 0, triedSources.concat('directfr'));
    }
    if (!triedSources.includes('tutvlive')) {
      nextSource = sources.find(s => s.type === 'tutvlive');
      if (nextSource) return updatePlayer(channelIndex, 'tutvlive', 0, triedSources.concat('tutvlive'));
    }
    if (!triedSources.includes('witv')) {
      nextSource = sources.find(s => s.type === 'witv');
      if (nextSource) return updatePlayer(channelIndex, 'witv', 0, triedSources.concat('witv'));
    }
    // No more sources
    alert('No working stream found for this channel.');
  }

  // --- Helper: Remove all event listeners from playerVideo ---
  function removeAllVideoListeners() {
    const oldVideo = document.getElementById('player-video');
    const clone = oldVideo.cloneNode(true);
    oldVideo.parentNode.replaceChild(clone, oldVideo);
    // Update all references
    window.playerVideo = clone;
    // Also update the local variable if declared with let/var
    playerVideo = clone;
  }

  // --- Helper: Cleanup all players and timeouts ---
  function cleanupPlayers() {
    if (window.hls) {
      try { window.hls.destroy(); } catch(e) {}
      window.hls = null;
    }
    if (window.dashjsPlayer) {
      try { window.dashjsPlayer.reset(); } catch(e) {}
      window.dashjsPlayer = null;
    }
    if (bufferCleanupInterval) {
      clearInterval(bufferCleanupInterval);
      bufferCleanupInterval = null;
    }
    // Remove video listeners
    removeAllVideoListeners();

    // Remove any iframe blocker overlay we added
    const existingBlocker = document.getElementById('iframe-blocker');
    if (existingBlocker && existingBlocker.parentNode) existingBlocker.parentNode.removeChild(existingBlocker);

    // Pause and reset video
    playerVideo.pause();
    playerVideo.removeAttribute('src');
    playerVideo.load();
    playerVideo.classList.remove('active');
    playerVideo.style.display = 'none';
    // Reset iframe
    playerIframe.src = '';
    playerIframe.classList.remove('active');
    playerIframe.style.display = 'none';
    // Clear timeouts
    if (m3u8Timeout) {
      clearTimeout(m3u8Timeout);
      m3u8Timeout = null;
    }
    m3u8Tried = false;
  }

  // --- New helper: init HLS with sane buffer limits & pruning ---
  function initHls(url) {
    window.hls = new Hls({
      enableWorker: true,
      lowLatencyMode: true,
      backBufferLength: HLS_BACK_BUFFER_SECONDS,
      maxBufferLength: HLS_MAX_BUFFER_LENGTH,
      maxMaxBufferLength: HLS_MAX_MAX_BUFFER_LENGTH,
      maxBufferSize: 30 * 1000 * 1000,     // ~30MB safety
      maxBufferHole: 0.5,
      liveSyncDuration: 4,
      liveMaxLatencyDuration: 10
    });
    window.hls.loadSource(url);
    window.hls.attachMedia(playerVideo);

    window.hls.on(Hls.Events.MANIFEST_PARSED, () => {
      playerVideo.play().catch(()=>{});
    });

    window.hls.on(Hls.Events.ERROR, (evt, data) => {
      if (data.fatal) {
        if (!m3u8Tried) {
          m3u8Tried = true;
          tryNextSource(currentChannelIndex, ['m3u8']);
        }
      }
    });

    // Manual periodic pruning (defensive in case backBufferLength not strictly enforced)
    bufferCleanupInterval = setInterval(() => {
      if (!window.hls || !playerVideo || playerVideo.readyState === 0) return;
      const current = playerVideo.currentTime;
      const pruneBefore = current - HLS_BACK_BUFFER_SECONDS;
      if (pruneBefore <= 0) return;
      const buffered = playerVideo.buffered;
      for (let i = 0; i < buffered.length; i++) {
        const start = buffered.start(i);
        const end = buffered.end(i);
        // Fully behind window
        if (end < pruneBefore) {
          window.hls.remove(start, end);
        } else if (start < pruneBefore && end > pruneBefore) {
          window.hls.remove(start, pruneBefore - 2); // leave tiny safety gap
        }
      }
      logApproxVideoBuffered();
    }, 15000);
  }

  // --- New helper: init DASH with buffer constraints ---
  function initDash(url) {
    window.dashjsPlayer = dashjs.MediaPlayer().create();
    window.dashjsPlayer.updateSettings({
      streaming: {
        abr: { limitBitrateByPortal: true },
        lowLatencyEnabled: true,
        buffer: {
          fastSwitchEnabled: true,
          bufferToKeep: 20,                // seconds retained behind
          stableBufferTime: 12,
          bufferTimeAtTopQuality: 20,
          bufferTimeAtTopQualityLongForm: 20,
          longFormContentDurationThreshold: 0
        },
        liveCatchUp: { enabled: true, playbackRate: 0.5, maxDrift: 0.5, minDrift: 0.02 }
      }
    });
    window.dashjsPlayer.initialize(playerVideo, url, true);

    // Optional extra prune (usually settings are enough)
    bufferCleanupInterval = setInterval(() => {
      if (!playerVideo) return;
      logApproxVideoBuffered();
    }, 30000);
  }

  // --- Main updatePlayer function (only replace HLS & DASH branches) ---
  function updatePlayer(channelIndex, sourceType, serverIdx = 0, triedSources = []) {
    currentChannelIndex = channelIndex;
    currentServerIndex = serverIdx;
    const channel = channels[currentChannelIndex];
    document.getElementById('current-channel-name').textContent = channel ? channel.name : '';
    if (!channel || !channel.sources || channel.sources.length === 0) {
      console.error('Invalid channel data:', channel);
      return;
    }

    // --- CLEANUP PREVIOUS PLAYERS ---
    cleanupPlayers();

    const sources = channel.sources;
    let source = null;
    if (sourceType) {
      if (sourceType === 'm3u8') {
        source = sources.find(s => s.type === 'm3u8' || (s.url && s.url.endsWith('.m3u8')));
      } else if (sourceType === 'mpd') {
        source = sources.find(s => s.type === 'mpd' || (s.url && s.url.endsWith('.mpd')));
      } else if (sourceType === 'tutvlive') {
        source = sources.find(s => s.type === 'tutvlive');
      } else if (sourceType === 'witv') {
        source = sources.find(s => s.type === 'witv');
      } else if (sourceType === 'directfr') {
        source = sources.find(s => s.type === 'directfr');
      }
    } else {
      source = sources.find(s => s.type === 'mpd' || (s.url && s.url.endsWith('.mpd')))
        || sources.find(s => s.type === 'm3u8' || (s.url && s.url.endsWith('.m3u8')))
        || sources.find(s => s.type === 'directfr')
        || sources.find(s => s.type === 'tutvlive')
        || sources.find(s => s.type === 'witv')
        || sources.find(s => s.type === 'daddylive'); // <-- add this line
      sourceType = source ? source.type : '';
    }
    if (!source) {
      console.error('No suitable source found for channel:', channel);
      return;
    }
    currentSourceType = sourceType;

    // Show server select for tutvlive
    if (sourceType === 'tutvlive' && source.servers && source.servers.length > 1) {
      populateServerSelect(source.servers);
      serverSelect.value = serverIdx;
      serverSelect.style.display = 'inline-block';
    } else {
      serverSelect.style.display = 'none';
    }

    let url;
    if (sourceType === 'witv') {
      url = witvBaseUrl + source.id + '&q=1080';
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = url;
      setTimeout(() => {
        player = new playerjs.Player(playerIframe);
        addPlayerListeners();
        player.play();
        player.unmute();
      }, 500);
    } else if (sourceType === 'tutvlive') {
      const server = source.servers[serverIdx] || source.servers[0];
      url = `${tutvliveBaseUrl}${server}/${source.id}`;
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = url;
      setTimeout(() => {
        player = new playerjs.Player(playerIframe);
        addPlayerListeners();
        player.play();
        player.unmute();
      }, 500);
    } else if (sourceType === 'm3u8') {
      url = source.url || source;
      playerVideo.classList.add('active');
      playerVideo.style.display = 'block';

      if (Hls.isSupported()) {
        initHls(url);
      } else if (playerVideo.canPlayType('application/vnd.apple.mpegurl')) {
        playerVideo.src = url;
        playerVideo.addEventListener('loadedmetadata', () => playerVideo.play(), { once: true });
      }

      m3u8Timeout = setTimeout(() => {
        if (playerVideo.paused && !m3u8Tried) {
          m3u8Tried = true;
          tryNextSource(channelIndex, triedSources.concat('m3u8'));
        }
      }, 10000);

      player = {
        play: () => playerVideo.play(),
        pause: () => playerVideo.pause(),
        getPaused: cb => cb(playerVideo.paused),
        mute: () => { playerVideo.muted = true; },
        unmute: () => { playerVideo.muted = false; },
        getMuted: cb => cb(playerVideo.muted)
      };
      addPlayerListeners();
      player.unmute();
    } else if (sourceType === 'mpd') {
      url = source.url || source;
      playerVideo.classList.add('active');
      playerVideo.style.display = 'block';
      initDash(url);

      player = {
        play: () => playerVideo.play(),
        pause: () => playerVideo.pause(),
        getPaused: cb => cb(playerVideo.paused),
        mute: () => { playerVideo.muted = true; },
        unmute: () => { playerVideo.muted = false; },
        getMuted: cb => cb(playerVideo.muted)
      };
      addPlayerListeners();
      player.unmute();
    } else if (sourceType === 'directfr') {
      url = directfrBaseUrl + source.id;
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = url;
      setTimeout(() => {
        player = new playerjs.Player(playerIframe);
        addPlayerListeners();
        player.play();
        player.unmute();
      }, 500);
    } else if (source.type === "daddylive" && source.channel_id) {
      // Only use 'stream' type for daddylive
      const streamUrl = `https://dlhd.dad/stream/stream-${source.channel_id}.php`;
      playerIframe.classList.add('active');
      playerIframe.style.display = 'block';
      playerIframe.src = streamUrl;
      playerIframe.setAttribute('allowfullscreen', 'true');
      playerIframe.setAttribute('loading', 'lazy');
      if (playerVideo) playerVideo.style.display = 'none';
      // No fallback to other types
      return;
    }
    // Show switch source if channel has more than 1 source
    switchServerBtn.style.display = sources.length > 1 ? 'inline-block' : 'none';
    populateChannelList();
  }

  serverSelect.addEventListener('change', (event) => {
    if (currentSourceType === 'tutvlive') {
      updatePlayer(currentChannelIndex, 'tutvlive', parseInt(event.target.value));
    }
  });

  switchServerBtn.addEventListener('click', () => {
    // Cycle to next available source type using new priority order
    const channel = channels[currentChannelIndex];
    const sources = channel.sources || [];
    const priority = ['mpd', 'm3u8', 'directfr', 'tutvlive', 'witv'];
    let idx = priority.indexOf(currentSourceType);
    for (let i = 1; i <= priority.length; i++) {
      const candidate = priority[(idx + i) % priority.length];
      if (sources.find(s => s.type === candidate)) {
        m3u8Tried = false;
        updatePlayer(currentChannelIndex, candidate);
        break;
      }
    }
  });

  fullscreenBtn.addEventListener('click', () => {
    // Determine which player is visible and request fullscreen accordingly
    if (playerVideo.classList.contains('active') && playerVideo.style.display === 'block') {
      if (playerVideo.requestFullscreen) {
        playerVideo.requestFullscreen();
      } else if (playerVideo.mozRequestFullScreen) {
        playerVideo.mozRequestFullScreen();
      } else if (playerVideo.webkitRequestFullscreen) {
        playerVideo.webkitRequestFullscreen();
      } else if (playerVideo.msRequestFullscreen) {
        playerVideo.msRequestFullscreen();
      }
    } else if (playerIframe.classList.contains('active') && playerIframe.style.display === 'block') {
      if (playerIframe.requestFullscreen) {
        playerIframe.requestFullscreen();
      } else if (playerIframe.mozRequestFullScreen) {
        playerIframe.mozRequestFullScreen();
      } else if (playerIframe.webkitRequestFullscreen) {
        playerIframe.webkitRequestFullscreen();
      } else if (playerIframe.msRequestFullscreen) {
        playerIframe.msRequestFullscreen();
      }
    }
    // menu-section reference for overlay logic
    const menuSection = document.getElementById('menu-section');
  });

  // --- Overlay logic for menu-section ---
  const menuSection = document.getElementById('menu-section');
  let overlayTimeout;

  function showMenuOverlay() {
    menuSection.classList.add('overlay-active');
  }
  function hideMenuOverlay() {
    menuSection.classList.remove('overlay-active');
  }
  function resetMenuOverlayTimer() {
    hideMenuOverlay();
    if (overlayTimeout) clearTimeout(overlayTimeout);
    overlayTimeout = setTimeout(showMenuOverlay, 5000);
  }

  // Controls logic
  let hideTimeout;
  function showControls() {
    controls.classList.remove('hidden');
    clearTimeout(hideTimeout);
    hideTimeout = setTimeout(() => {
      controls.classList.add('hidden');
      showMenuOverlay();
    }, 5000);
    hideMenuOverlay();
  }

  // Mouse cursor hide logic
  let cursorTimeout;

  // central setter that toggles both the CSS class and explicit element cursor styles
  function setCursorHidden(hidden) {
    document.body.classList.toggle('hide-cursor', hidden);
    const value = hidden ? 'none' : '';
    // apply explicit cursor style to elements that can otherwise show it (iframe/video/controls/menu)
    document.body.style.cursor = value;
    if (playerIframe) playerIframe.style.cursor = value;
    if (playerVideo) playerVideo.style.cursor = value;
    if (controls) controls.style.cursor = value;
    if (menuSection) menuSection.style.cursor = value;
    // also try the root element
    document.documentElement.style.cursor = value;
  }

  function showCursor() {
    // show immediately and restart hide timer
    setCursorHidden(false);
    if (cursorTimeout) clearTimeout(cursorTimeout);
    cursorTimeout = setTimeout(() => {
      setCursorHidden(true);
    }, 5000);
  }

  // Listen for mouse movement to reset all timers
  document.addEventListener('mousemove', () => {
    resetMenuOverlayTimer();
    showControls();
    showCursor();
  });

  // Start timers on load
  resetMenuOverlayTimer();
  showControls();
  showCursor();

  // Loading-screen logic: remove the loading video after it plays once
  (function() {
    const loadingVideo = document.getElementById('loading-video');
    if (!loadingVideo) return;

    // Ensure playsInline & muted for autoplay policies
    loadingVideo.muted = true;
    loadingVideo.playsInline = true;

    // Try to play (some environments require explicit play())
    loadingVideo.play().catch(() => { /* ignore autoplay rejection */ });

    function removeLoadingVideo() {
      if (!loadingVideo.parentNode) return;
      loadingVideo.style.opacity = '0';
      setTimeout(() => {
        if (loadingVideo.parentNode) loadingVideo.parentNode.removeChild(loadingVideo);
      }, 600);
    }

    loadingVideo.addEventListener('ended', removeLoadingVideo, { once: true });

    // Fallback: remove after a maximum duration in case 'ended' doesn't fire
    const MAX_FALLBACK_MS = 30000;
    setTimeout(() => {
      if (document.getElementById('loading-video')) removeLoadingVideo();
    }, MAX_FALLBACK_MS);

    // Optional: allow click to skip the loading video (unobtrusive)
    loadingVideo.addEventListener('click', removeLoadingVideo);
  })();
</script>
</body>
</html>
